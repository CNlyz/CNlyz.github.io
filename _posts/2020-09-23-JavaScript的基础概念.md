---
title: JavaScript的基础概念
date: 2020-09-24 09:00:00 +0800
categories: [前端, JavaScript]
tags: [javascript]
---

# 编译相关
* [词法分析](#词法分析)
* [语法分析](#语法分析)
* [解释执行](#解释执行)
* [预编译](#预编译)
* [优化](#优化)

## 词法分析
将源代码的文本字符串根据空格符或者换行符, 转成token(标记)的过程, 每个token里会包含
* value: 值
* label: 类型(var, for, while, name...)
* start/end: 起始位置

## 语法分析
将上述的token转成AST(Abstract Syntax Tree)

## 预编译
预编译, 当JavaScript引擎解析脚本时, 它会在预编译期对所有声明的变量和函数进行处理! 并且是先预声明变量, 再预定义函数! 变量提升即发生在这个阶段

## 解释执行
引擎在这个阶段会构建作用域链, 并且在执行时根据作用域链检索变量

## 优化
引擎会根据AST一边解释一边执行, 但是存在一个可优化的空间, 当一段代码被多次执行后, 如果相关的变量类型不变, 那么就不再需要每次都解释再执行, 可以先编译, 然后执行。因此, 现代JavaScript引擎都会加入JIT(Just In Time, 运行时编译), 具体做法如下：

1. 监控代码的运行情况, 当一段代码运行了多次并达到某个阈值后, 会被标记为`warm`, 如果继续运行多次达到一个更大的阈值, 会被标记为`hot`.
2. 如果一段代码被标记成`warm`了, 引擎会把这段代码放到基线编译器进行编译(这个编译相比优化编译器的编译速度会快一点), 存储编译结果, 用于后续的继续执行
3. 如果一段代码被标记成`hot`了, 引擎会把这段代码放到优化编译器进行编译, 生成一个更加高效的版本, 存储编译结果, 用于后续执行
4. JavaScript毕竟是动态类型的语言, `warm`或者`hot`的代码在后续执行时如果遇到了类型变更, 例如循环网数组里添加元素, 前面添加的都是整数, 突然加一个字符串, 这是后引擎会认为这段编译结果不再可靠, 会将期丢弃, 退回到一遍解释一遍执行。这叫做去优化

# this
JavaScript的`this`即作用域的环境对象(例如全局作用域里的就是`window`), 并且是在运行时确定, 这一点和作用域链是在解释执行前, 基于AST确定的(词法作用域)完全不同

一个比较难懂的例子:
```js
function foo() {
  console.log(this.a)
}
function doFoo(fn) {
  fn()
}
var obj = { a: 1, foo: foo }
a = "global"
doFoo(obj.foo) // global
```
第一直觉应该是输出`1`, 但其实输出的是`global`。原因是`doFoo`函数将`obj.foo`复制给了`fn`(基于引用), 因此代码实际是这么运行的:
```js
// 伪代码, 大括号表示doFoo函数的作用域
{
    fn = foo;
    fn();
}
```
doFoo函数的作用域的`this`对象没有`a`属性, 因此向外层作用域查找, 找到全局作用域的`a`属性